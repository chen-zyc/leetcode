- [476. 数字的补数](#476-数字的补数)


------------------------------

# 476. 数字的补数

对整数的二进制表示取反（0 变 1 ，1 变 0）后，再转换为十进制表示，可以得到这个整数的补数。

例如，整数 5 的二进制表示是 "101" ，取反后得到 "010" ，再转回十进制表示得到补数 2 。

给你一个整数 num ，输出它的补数。
 
示例 1：

```
输入：num = 5
输出：2
解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。
```

示例 2：

```
输入：num = 1
输出：0
解释：1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。
```

提示：

- $1 <= num < 2^{31}$

链接：https://leetcode-cn.com/problems/number-complement


**解答**

取反直接使用 `!num` 就可以了，但是这个题目有个隐藏的条件，比如 5 的二进制是 `0b_101`，最左边的 1 的前面还有很多 0 呢，在取反的时候是不对这些 0 进行取反的。所以直接用 `!num` 是不行的。

考虑用异或，比如 `0b_101 ^ 0b_111`，0 和 0 异或的结果还是 0，1 和 1 异或的结果是 0，0 和 1 异或的结果是 1，这样就达到了把 1 变成 0，把 0 变成 1 的效果了，所以现在的问题是怎么求出 `0b_111` 这个数，也就是怎么求出对右边几位比特进行取反操作。

可以算出来 num 有几个前导零，然后剩下的数就是需要取反的位数了。

```rs
pub fn find_complement(num: i32) -> i32 {
    // 总的位数 - 前面 0 的位数 = 需要取反的位数
    let bits = i32::BITS - num.leading_zeros();
    // 只有后面 bits 位是 1。
    let mask = (1 << bits) - 1;
    println!(
        "num: {:b}, bits: {}, mask: {:b}, res: {:b}",
        num,
        bits,
        mask,
        num ^ mask
    );
    // num 和 mask 前面几位都是 0，所以异或的结果还是 0。后面几位 mask 是 1，异或的结果就是原来的 0 变成 1，1 变成 0。
    num ^ mask

    // 上面操作的简化版。
    // num ^ ((1 << (i32::BITS - num.leading_zeros())) - 1)
}
```