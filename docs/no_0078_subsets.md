- [78. 子集](#78-子集)
  - [官方题解](#官方题解)
    - [方法一：迭代法实现子集枚举](#方法一迭代法实现子集枚举)
    - [方法二：递归法实现子集枚举](#方法二递归法实现子集枚举)


------------------------------

# 78. 子集

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例:

```
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

- 来源：力扣（LeetCode）
- 链接：https://leetcode-cn.com/problems/subsets
- 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。


## 官方题解

> 链接：https://leetcode-cn.com/problems/subsets/solution/zi-ji-by-leetcode-solution/

### 方法一：迭代法实现子集枚举

记原序列中元素的总数为 $n$。原序列中的每个数字 $a_i$ 的状态可能有两种，即「在子集中」和「不在子集中」。我们用 1 表示「在子集中」，0 表示不在子集中，那么每一个子集可以对应一个长度为 $n$ 的 0/1 序列，第 i 位表示 $a_i$ 是否在子集中。例如，$n = 3$，$a = \{ 5, 2, 9 \}$ 时：

| 0/1 序列 | 子集            | 0/10/1 序列对应的二进制数 |
| :------- | :-------------- | :------------------------ |
| 000      | $\{ \}$         | 0                         |
| 001      | $\{ 9 \}$       | 1                         |
| 010      | $\{ 2 \}$       | 2                         |
| 011      | $\{ 2, 9 \}$    | 3                         |
| 100      | $\{ 5 \}$       | 4                         |
| 101      | $\{ 5, 9 \}$    | 5                         |
| 110      | $\{ 5, 2 \}$    | 6                         |
| 111      | $\{ 5, 2, 9 \}$ | 7                         |

可以发现 0/1 序列对应的二进制数正好从 $0$ 到 $2^n - 1$。我们可以枚举 ${\rm mask} \in [0, 2^n - 1]$，$\rm mask$ 的二进制表示是一个 0/1 序列，我们可以按照这个 0/1 序列在原集合当中取数。当我们枚举完所有 $2^n$ 个 $\rm mask$，我们也就能构造出所有的子集。

```go
func subsets(nums []int) (ans [][]int) {
    n := len(nums)
    for mask := 0; mask < 1<<n; mask++ {
        set := []int{}
        for i, v := range nums {
            if mask>>i&1 > 0 {
                set = append(set, v)
            }
        }
        ans = append(ans, append([]int(nil), set...))
    }
    return
}
```

**复杂度分析**

- 时间复杂度：$O(n \times 2^n)$。一共 $2^n$ 个状态，每种状态需要 $O(n)$ 的时间来构造子集。
- 空间复杂度：$O(n)$。即构造子集使用的临时数组 t 的空间代价。



### 方法二：递归法实现子集枚举

我们也可以用递归来实现子集枚举。

假设我们需要找到一个长度为 n 的序列 $a$ 的所有子序列，代码框架是这样的：

```c++
vector<int> t;
void dfs(int cur, int n) {
    if (cur == n) {
        // 记录答案
        // ...
        return;
    }
    // 考虑选择当前位置
    t.push_back(cur);
    dfs(cur + 1, n, k);
    t.pop_back();
    // 考虑不选择当前位置
    dfs(cur + 1, n, k);
}
```

上面的代码中，${\rm dfs(cur,} n)$ 参数表示当前位置是 $\rm cur$，原序列总长度为 $n$。原序列的每个位置在答案序列中的状态有被选中和不被选中两种，我们用 $\rm t$ 数组存放已经被选出的数字。在进入 ${\rm dfs(cur,} n)$ 之前 $\rm [0, cur - 1]$ 位置的状态是确定的，而 $[{\rm cur}, n - 1]$ 内位置的状态是不确定的，${\rm dfs(cur,} n)$ 需要确定 $\rm cur$ 位置的状态，然后求解子问题 ${\rm dfs(cur + 1}, n)$。对于 $\rm cur$ 位置，我们需要考虑 $a[{\rm cur}]$ 取或者不取，如果取，我们需要把 $a[{\rm cur}]$ 放入一个临时的答案数组中（即上面代码中的 $\rm t$），再执行 ${\rm dfs(cur + 1}, n)$，执行结束后需要对 $\rm t$ 进行回溯；如果不取，则直接执行 ${\rm dfs(cur + 1}, n)$。在整个递归调用的过程中，$\rm cur$ 是从小到大递增的，当 $\rm cur$ 增加到 $n$ 的时候，记录答案并终止递归。可以看出二进制枚举的时间复杂度是 $O(2 ^ n)$。

```go
func subsets(nums []int) (ans [][]int) {
    set := []int{}
    var dfs func(int)
    dfs = func(cur int) {
        if cur == len(nums) {
            ans = append(ans, append([]int(nil), set...))
            return
        }
        set = append(set, nums[cur])
        dfs(cur + 1)
        set = set[:len(set)-1]
        dfs(cur + 1)
    }
    dfs(0)
    return
}
```

- 时间复杂度：$O(n \times 2 ^ n)$。一共 $2^n$ 个状态，每种状态需要 $O(n)$ 的时间来构造子集。
- 空间复杂度：$O(n)$。临时数组 t 的空间代价是 $O(n)$，递归时栈空间的代价为 $O(n)$。
