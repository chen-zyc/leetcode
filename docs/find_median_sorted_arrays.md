# 寻找两个有序数组的中位数

[链接](https://leetcode-cn.com/problems/median-of-two-sorted-arrays)

给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 $O(log(m + n))$。

你可以假设 nums1 和 nums2 不会同时为空。

示例 1:

```
nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
```

示例 2:

```
nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5
```

## 我的总结

假设已经分好了：

```
        left_part            |        right_part
（1）A[0], A[1], ..., A[i-1]  |  （2）A[i], A[i+1], ..., A[m-1]
（3）B[0], B[1], ..., B[j-1]  |  （4）B[j], B[j+1], ..., B[n-1]
```

需要满足：
1. `len(left_part) == len(right_part)` 或者 `len(left_part) == len(right_part) + 1`.
2. `A[i-1] <= B[j] && B[j-1] <= A[i]`.

由 (1) 能够推出 i 和 j 的关系：

```
i + j == m-i + n-j => j = (m+n)/2 - i (m+n 是偶数时)
或者：
i + j == m-i + n-j + 1 => j = (m+n+1)/2 - i (m+n 是奇数时)
```

假设 m+n=4, 第一个公式得到 j=2-i, 第二个公式也是 j=2-i.

假设 m+n=3, 第一个公式得到 j=1-i, 第二个公式是 j=2-i. 第一个公式得到的是错误的。

所以使用第二个公式可以利用整数的除法会去掉小数部分来覆盖奇偶这两种情况。后面就使用第二种方法了。

因为 j 是索引，不能小于 0, 推导有：

```
j = (m+n+1)/2-i >= (m+n+1)/2-m (因为 i<= m)
=> j >= (n-m+1)/2 >= 0
=> n-m+1 >= 0
=> m <= n+1 (好像也不是完全的 m<= n)
```

也就是说 i 在 数量少的那个数组上遍历。

**为什么 i 可以等于 m?**: i == m 时 （2） 区是空的，如果不能等于 m，那只要 A 有一个，那就会在（2）区。

---------------------------

然后再说：`A[i-1] <= B[j] && B[j-1] <= A[i]` 的边界条件：

- 如果（1）区是空的，那么对应 i == 0; `A[i-1] <= B[j]` 自然就成立。
- 如果（2）区是空的，那么对应 i == m; `B[j-1] <= A[i]` 自然就成立（左边确实都小于右边了）。
- 如果（3）区是空的，那么对应 j == 0; `B[j-1] <= A[i]` 自然就成立。
- 如果（4）区是空的，那么对应 j == n; `A[i-1] <= B[j]` 自然就成立。

所以 `A[i-1] <= B[j] && B[j-1] <= A[i]` 加上边界条件就是：

```
((i == 0) || (j == n) || (A[i-1] <= B[j]))
&&
((i == m) || (j == 0) || (B[j-1] <= A[i]))

重点来了，对上面取反：
((i > 0) && (j < n) && (A[i-1] > B[j]))
||
((i < m) && (j > 0) && (B[j-1] > A[i]))
```

`((i > 0) && (j < n) && (A[i-1] > B[j]))` 时 `A[i-1]` 太小了，所以让 i 变大以便让 `A[i-1]` 变大（因为是有序数组）。

`((i < m) && (j > 0) && (B[j-1] > A[i]))` 时 `A[i]` 太小了，所以让 i 变大点。

---------------------------

示例：`A: [3], B: [1, 2]`, half = $\frac{1+2+1}{2} = 2$

| i 的范围 | i                 | j       | 分割图形                                                                | 说明                   |
| -------- | ----------------- | ------- | ----------------------------------------------------------------------- | ---------------------- |
| $[0, 1]$ | $\frac{0+1}{2}=0$ | $2-i=2$ | $\begin{bmatrix}&\\1&2\end{bmatrix}$$\begin{bmatrix}3\\&\end{bmatrix}$ | 满足条件，中位数是 $2$ |

---------------------------

示例：`A: [1, 3], B: [2, 4]`, half = $\frac{2+2+1}{2} = 2$

| i 的范围 | i                 | j       | 分割图形                                                                | 说明                   |
| -------- | ----------------- | ------- | ----------------------------------------------------------------------- | ---------------------- |
| $[0, 2]$ | $\frac{0+2}{2}=1$ | $2-i=1$ | $\begin{bmatrix}1\\2\end{bmatrix}$$\begin{bmatrix}3\\4\end{bmatrix}$ | 满足条件，中位数是 $\frac{2+3}{2}=2.5$ |

---------------------------

示例：`A: [1, 3, 5], B: [2, 4, 6]`, half = $\frac{3+3+1}{2} = 3$

| i 的范围 | i                 | j       | 分割图形                                                                | 说明                   |
| -------- | ----------------- | ------- | ----------------------------------------------------------------------- | ---------------------- |
| $[0, 3]$ | $\frac{0+3}{2}=1$ | $3-i=2$ | $\begin{bmatrix}&1\\2&4\end{bmatrix}$$\begin{bmatrix}3&5\\6&\end{bmatrix}$ | 4>3，i 应该变大,范围变成$[i+1,3]$ |
| $[2, 3]$ | $\frac{2+3}{2}=2$ | $3-i=1$ | $\begin{bmatrix}1&3\\&2\end{bmatrix}$$\begin{bmatrix}5&\\4&6\end{bmatrix}$ | 满足，中位数是$\frac{3+4}{2}=3.5$ |


---------------------------

示例：`A: [1], B: [2, 3, 4]`, half = $\frac{1+3+1}{2} = 2$

| i 的范围 | i                 | j       | 分割图形                                                                | 说明                   |
| -------- | ----------------- | ------- | ----------------------------------------------------------------------- | ---------------------- |
| $[0, 1]$ | $\frac{0+1}{2}=0$ | $2-i=2$ | $\begin{bmatrix}&\\2&3\end{bmatrix}$$\begin{bmatrix}1&\\4&\end{bmatrix}$ | 3>1，i 应该变大,范围变成$[i+1,1]$ |
| $[1, 1]$ | $\frac{1+1}{2}=1$ | $2-i=1$ | $\begin{bmatrix}&1\\&2\end{bmatrix}$$\begin{bmatrix}&\\3&4\end{bmatrix}$ | 满足，中位数是$\frac{2+3}{2}=2.5$ |



## 原文

链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu-b/

## 方法：递归法

为了解决这个问题，我们需要理解 “中位数的作用是什么”。在统计中，中位数被用来：

> 将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。

如果理解了中位数的划分作用，我们就很接近答案了。

首先，让我们在任一位置 i 将 A 划分成两个部分：

```
          left_A             |        right_A
    A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]
```

由于 A 中有 m 个元素， 所以我们有 m+1 种划分的方法（$i = 0 \sim m$）。

我们知道：

$$
\text{len}(\text{left\_A}) = i, \text{len}(\text{right\_A}) = m - i
$$

注意：当 i = 0 时，`left_A` 为空集， 而当 i = m 时, `right_A` 为空集。

> 如果 i 不能将 A 平分呢？比如 A 有 4 个元素，i 取多少呢？后面的公式考虑了这种情况。

采用同样的方式，我们在任一位置 j 将 B 划分成两个部分：

```
          left_B             |        right_B
    B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]
```

$$
\text{len}(\text{left\_B}) = j, \text{len}(\text{right\_B}) = n - j
$$

将 `left_A` 和 `left_B` 放入一个集合，并将 `right_A` 和 `right_B` 放入另一个集合。 再把这两个新的集合分别命名为 `left_part` 和 `right_part`：

```
          left_part          |        right_part
    A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]
    B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]
```

如果我们可以确认：

1. `len(left_part) = len(right_part)`
2. `max(left_part) <= min(right_part)`

那么，我们已经将 $\{\text{A}, \text{B}\}$ 中的所有元素划分为相同长度的两个部分，且其中一部分中的元素总是大于另一部分中的元素。那么：

$$
\text{median} = \frac{\text{max}(\text{left}\_\text{part}) + \text{min}(\text{right}\_\text{part})}{2}
$$

要确保这两个条件，我们只需要保证(**这下面两个公式最重要**)：

1. $i + j = m - i + n - j$（或：$m - i + n - j + 1$, 左边比右边多一个的情况）
    如果 $n \geq m$，只需要使 $\ i = 0 \sim m,\ j = \frac{m + n + 1}{2} - i$. (确保两边长度相同)
2. $\text{B}[j-1] \leq \text{A}[i]$ 以及 $\text{A}[i-1] \leq \text{B}[j]$. (确保 max(left) <= min(right))

ps.1 为了简化分析，我假设 `A[i−1],B[j−1],A[i],B[j]` 总是存在，哪怕出现 i=0，i=m，j=0，或是 j=n 这样的临界条件(四个部分有的为空的情况)。 我将在最后讨论如何处理这些临界值。

ps.2 为什么 `n >= m`？由于 `0<=i<=m` 且 $j = \frac{m + n + 1}{2} - i$，我必须确保 j 不是负数。如果 `n < m`，那么 j 将可能是负数，而这会造成错误的答案。(也就是说要遍历小的列表)


```
m + n 是偶数的时候，两边正好平分：
   i + j = m - i + n - j
=> 2j = m + n - 2i
=> j = (m + n) / 2 - i

m + n 是奇数的时候，右边比左边多1个：
如果 i + j = m - i + n - j + 1
=>  2j = m + n + 1 - 2i
=>   j = (m + n + 1) / 2 - i

代码中用的是第二个，为什么不考虑第一种情况呢？
如果 m+n 是偶数，那么 (m+n+1)/2 是结果和 (m+n)/2 的结果是一样的，因为会忽略掉小数部分。
```

所以，我们需要做的是：

在 `[0，m]` 中搜索并找到目标对象 i，以使：`B[j−1] <= A[i]` 且 `A[i−1] <= B[j]`, 其中 $j = \frac{m + n + 1}{2} - i$

接着，我们可以按照以下步骤来进行二叉树搜索：

1. 设 `imin=0, imax=m`, 然后开始在 `[imin, imax]` 中进行搜索。
2. 令 $i = \frac{\text{imin} + \text{imax}}{2}, j = \frac{m + n + 1}{2} - i$
3. 现在我们有 `len(left_part) = len(right_part)`。 而且我们只会遇到三种情况：
    1. `B[j−1] <= A[i]` 且 `A[i−1] <= B[j]`：这意味着我们找到了目标对象 i，所以可以停止搜索。
    2. `B[j−1] > A[i]`： 这意味着 `A[i]` 太小，我们必须调整 i 以使 `B[j−1] <= A[i]`。
        - 我们可以增大 i 吗？是的，因为当 i 被增大的时候，j 就会被减小。因此 `B[j−1]` 会减小，而 `A[i]` 会增大，那么 `B[j−1] <= A[i]` 就可能被满足。
        - 我们可以减小 i 吗？不行，因为当 i 被减小的时候，j 就会被增大。因此 `B[j−1]` 会增大，而 `A[i]` 会减小，那么 `B[j−1] <= A[i]` 就可能不满足。
        - 所以我们必须增大 i。也就是说，我们必须将搜索范围调整为 `[i+1, imax]`。
        - 因此，设 `imin = i+1`，并转到步骤 2。
    3. `A[i−1] > B[j]`：这意味着 `A[i−1]` 太大，我们必须减小 i 以使 `A[i−1] <= B[j]`。也就是说，我们必须将搜索范围调整为 `[imin, i−1]`。因此，设 `imax = i−1`，并转到步骤 2。

当找到目标对象 i 时，中位数为：

- `max(A[i−1], B[j−1])`, 当 m + n 为奇数时.(左边多，所以中位数在左边)
- $\frac{\max(\text{A}[i-1], \text{B}[j-1]) + \min(\text{A}[i], \text{B}[j])}{2}$, 当 m + n 为偶数时。（左右一样多，取左边最大的和右边最小的取平均值）

------------------------------

现在，让我们来考虑这些临界值 `i=0,i=m,j=0,j=n`，此时 `A[i−1],B[j−1],A[i],B[j]` 可能不存在。其实这种情况比你想象的要容易得多。

我们需要做的是确保 `max(left_part) <= min(right_part)`。 因此，如果 i 和 j 不是临界值（这意味着 `A[i−1],B[j−1],A[i],B[j]` 全部存在）, 那么我们必须同时检查 `B[j−1] <= A[i]` 以及 `A[i−1] <= B[j]` 是否成立。但是如果 `A[i−1],B[j−1],A[i],B[j]` 中部分不存在，那么我们只需要检查这两个条件中的一个（或不需要检查）。

举个例子，如果 `i = 0`，那么 `A[i−1]` 不存在，我们就不需要检查 `A[i−1] <= B[j]` 是否成立。

所以，我们需要做的是：

在 `[0，m]` 中搜索并找到目标对象 i，以使：

(`j=0 || i=m || B[j−1]<=A[i]`) 或是 (`i=0 || j=n || A[i−1] <= B[j]`), 其中 $j = \frac{m + n + 1}{2} - i$

**j == 0 表明左下角为空； i == m 表明 右上角为空； 同理，i == 0 表明左上角为空；j == n 表明右下角为空。**

在循环搜索中，我们只会遇到三种情况：

1. (`j = 0 || i = m || B[j−1] <= A[i]`) 或是 (`i = 0 || j = n || A[i−1] <= B[j]`)，这意味着 i 是完美的，我们可以停止搜索。
2. `j > 0 && i < m && B[j−1]>A[i]` 这意味着 i 太小，我们必须增大它。(`j>0` 和 `i<m` 都是要保证访问 `B[j-1]` 和 `A[i]` 不溢出)。
3. `i > 0 && j < n && A[i−1]>B[j]` 这意味着 i 太大，我们必须减小它。

感谢 @Quentin.chen 指出：`i<m ⟹ j>0` 以及 `i>0 ⟹ j<n` 始终成立，这是因为：

$$
m \leq n,\ i < m \implies j = \frac{m+n+1}{2} - i > \frac{m+n+1}{2} - m \geq \frac{2m+1}{2} - m \geq 0
$$
$$
m \leq n,\ i > 0 \implies j = \frac{m+n+1}{2} - i < \frac{m+n+1}{2} \leq \frac{2n+1}{2} \leq n
$$

所以，在情况 2 和 3 中，我们不需要检查 `j > 0` 或是 `j < n` 是否成立。

```java
class Solution {
    public double findMedianSortedArrays(int[] A, int[] B) {
        int m = A.length;
        int n = B.length;
        if (m > n) { // to ensure m<=n
            int[] temp = A; A = B; B = temp;
            int tmp = m; m = n; n = tmp;
        }
        int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2;
        while (iMin <= iMax) {
            int i = (iMin + iMax) / 2;
            int j = halfLen - i;
            if (i < iMax && B[j-1] > A[i]){
                iMin = i + 1; // i is too small
            }
            else if (i > iMin && A[i-1] > B[j]) {
                iMax = i - 1; // i is too big
            }
            else { // i is perfect
                int maxLeft = 0;
                if (i == 0) { maxLeft = B[j-1]; }
                else if (j == 0) { maxLeft = A[i-1]; }
                else { maxLeft = Math.max(A[i-1], B[j-1]); }
                if ( (m + n) % 2 == 1 ) { return maxLeft; }

                int minRight = 0;
                if (i == m) { minRight = B[j]; }
                else if (j == n) { minRight = A[i]; }
                else { minRight = Math.min(B[j], A[i]); }

                return (maxLeft + minRight) / 2.0;
            }
        }
        return 0.0;
    }
}
```

复杂度分析

时间复杂度：$O(log(min(m,n)))$，

首先，查找的区间是 `[0, m]`。 而该区间的长度在每次循环之后都会减少为原来的一半。 所以，我们只需要执行 $\log(m)$ 次循环。由于我们在每次循环中进行常量次数的操作，所以时间复杂度为 $O\big(\log(m)\big)$。 由于 `m <= n`，所以时间复杂度是 $O\big(\log\big(\text{min}(m,n)\big)\big)$。

空间复杂度：$O(1)$，

我们只需要恒定的内存来存储 9 个局部变量， 所以空间复杂度为 $O(1)$。
