- [546. 移除盒子](#546-移除盒子)
  - [题目](#题目)
  - [题解](#题解)
    - [方法一：动态规划](#方法一动态规划)

------------------------------

# 546. 移除盒子

## 题目

给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。
你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k >= 1），这样一轮之后你将得到 `k*k` 个积分。
当你将所有盒子都去掉之后，求你能获得的最大积分和。

示例：

```
输入：boxes = [1,3,2,2,2,3,4,3,1]
输出：23
解释：
[1, 3, 2, 2, 2, 3, 4, 3, 1] 
----> [1, 3, 3, 4, 3, 1] (3*3=9 分) 
----> [1, 3, 3, 3, 1] (1*1=1 分) 
----> [1, 1] (3*3=9 分) 
----> [] (2*2=4 分)
```

提示：

- 1 <= boxes.length <= 100
- 1 <= `boxes[i]` <= 100

--------------------

- 来源：力扣（LeetCode）
- 链接：https://leetcode-cn.com/problems/remove-boxes
- 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。


## 题解

> 链接：https://leetcode-cn.com/problems/remove-boxes/solution/yi-chu-he-zi-by-leetcode-solution/

### 方法一：动态规划

**思路与算法**

我们很容易陷入这样一个错误的思路：用 $f(l, r)$ 来表示移除区间 $[l, r]$ 内所有的盒子能得到的最大积分，然后去探索某一种移除盒子的策略来进行状态转移。而实际上，我们并不能直接使用起始节点和结束节点决定最大分数，因为这个分数并不只依赖于子序列，也依赖于之前的移动对当前数组的影响，这可能让最终的子序列不是一个连续的子串。比如 $\{ 3, 4, 2, 4, 4 \}$，如果先把 2 移除，3 个 4 会合并在一起，对答案的贡献是 $3^2 = 9$，如果先移除左右两边的 4 再移除 2 这里 3 个 4 的贡献就是 $1^2 + 2^2 = 5$，最优的办法当然是先取走 2，但是这样剩下的 3 个 4 其实并不是原串的某个连续子串。

我们可以换一种思路，用 $f(l, r, k)$ 表示**移除**区间 $[l, r]$ 加上该区间右边等于 $a_r$(就是和区间最后一个元素相同的) 的 k 个元素组成的这个序列的最大积分。例如序列 $\{ 6, 3, 6, 5, 6, 7, 6, 6, 8, 6 \}$，$l = 1$（下标从 1 开始），$r = 5$，那么 $f(l, r, 3)$ 对应的元素就是 $\{ {\color{red}[6, 3, 6, 5, 6]}, 7, {\color{red}6}, {\color{red}6}, 8, {\color{red}6} \}$ 中标记为红色的部分。$f(l, r, k)$ 的定义是**移除这个红色的序列获得的最大积分**。请注意此时我们约定 7 和 8 已经先被移除，所以在这个状态下我们可以认为最后四个 6 是连续的，也就是说实际上序列是这样的：$\{ [6, 3, 6, 5, 6], 6, 6, 6 \}$，此时我们可以有这样一些策略来移除盒子：

- $\{ {\color{orange}[6, 3, 6, 5}, {\color{red} 6], 6, 6, 6} \}$，删除后面的四个 6，再删除前面的这个区间，这样获得的分数为 $f(1, 4, 0) + 4^2$
- $\{ {\color{orange}[6, 3}, {\color{red}6]}, [5], {\color{red} 6, 6, 6, 6} \}$，删除一个 5，然后后面的 5 个 6 一起删除，再删除前面的橘黄色区间，这样获得的分数是 $f(1, 3, 4) + f(4, 4, 0)$
- $\{ {\color{orange}[ }{\color{red}6]},[3, 6, 5], {\color{red} 6, 6, 6, 6} \}$，删除 3、6、5 之后再删除 5 个 6，这样获得的分数是 $f(1, 1, 4) + f(2, 4, 0)$

这个就是我们转移的时候使用的策略，我们可以推导出这样的动态规划转移方程：

$$
f(l, r, k) = \max \left\{ f(l, r - 1, 0) + (k + 1)^2, \max_{i = l}^{r - 1} \{ [f(l, i, k + 1) + f(i + 1, r - 1, 0)] \times { \color{red} \epsilon (a_i == a_r)} \} \right\}
$$

- $f(l, r - 1, 0) + (k + 1)^2$ 代表我们把 $a_r$ 和后面的 k 个数一起删除，再删除 $[l, r - 1]$ 这个区间
- $[f(l, i, k + 1) + f(i + 1, r - 1, 0)] \times { \color{red} \epsilon (a_i == a_r)}$ 代表当 $a_i (l \leq i < r)$ 等于 $a_r$	的时候，考虑先删掉 $[i + 1, r - 1]$ 这个区间，然后再删除 $[l, i]$ 区间和后面的 $k + 1$ 个和 $a_r$ 相等的数构成的序列，其中 $\epsilon(x)$ 为选择函数：

$$
\epsilon(x) = \left \{ \begin{aligned} & 1 ,& x == {\rm True} & \\ & 0 ,& x == {\rm False} \end{aligned} \right .
$$

这样我们就可以计算出 $f(1, n, 0)$ 的值，即为答案。

```go
func removeBoxes(boxes []int) int {
    dp := [100][100][100]int{}
    var calculatePoints func(boxes []int, l, r, k int) int
    calculatePoints = func(boxes []int, l, r, k int) int {
        if l > r {
            return 0
        }
        if dp[l][r][k] != 0 {
            return dp[l][r][k]
        }
        // 最后边有连续 k 个相同的数
        for r > l && boxes[r] == boxes[r - 1] {
            r--
            k++
        }
        // 把右边的删除的那种情况：f(l, r-1, 0) + (k + 1)^2
        dp[l][r][k] = calculatePoints(boxes, l, r - 1, 0) + (k + 1) * (k + 1)
        // 第二种情况，先删掉中间的一部分，最后再把剩下的删除
        for i := l; i < r; i++ {
            if boxes[i] == boxes[r] {
                // calculatePoints(boxes, i + 1, r - 1, 0) 表示中间这部分的最高得分。
                // calculatePoints(boxes, l, i, k + 1) 表示把中间那部分删除后，后面的连成一片后的最高得分。
                dp[l][r][k] = max(dp[l][r][k], calculatePoints(boxes, l, i, k + 1) + calculatePoints(boxes, i + 1, r - 1, 0))
            }
        }
        return dp[l][r][k]
    }
    return calculatePoints(boxes, 0, len(boxes) - 1, 0)
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
```

**复杂度分析**

- 时间复杂度：$O(n^4)$。最坏情况下每个 $f(l, r, k)$ 被计算一次，每次状态转移需要 $O(n)$ 的时间复杂度。TODO: ??? 为什么是 4 次方 ???
- 空间复杂度：$O(n^3)$。dp 数组的空间代价是 $O(n^3)$，递归使用栈空间的代价为 $O(n)$。

还可以看看[这个](https://leetcode-cn.com/problems/remove-boxes/solution/guan-fang-fang-fa-2ji-yi-hua-sou-suo-dong-hua-tu-j/)题解。